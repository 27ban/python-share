### 计算机网络

#### TCP/IP 四层协议

- 应用层：比如 HTTP、DNS、FTP、SMTP 协议等
- 传输层： TCP 和 UDP，提供端到端的服务
- 网络层： IP 协议，提供点到点的服务
- 链路层： 操作系统中的设备驱动程序、计算机中对应的网络接口卡

![PNG](\images\tcp_ip4.png)

#### TCP 协议

##### TCP 的特性

- TCP 提供一种面向连接的、可靠的字节流服务
- 在一个 TCP 连接中，仅有两方进行彼此通信。广播和多播不能用于 TCP
- TCP 使用校验和，确认和重传机制来保证可靠传输
- TCP 给数据分节进行排序，并使用累积确认保证数据的顺序不变和非重复
- TCP 使用滑动窗口机制来实现流量控制，通过动态改变窗口的大小进行拥塞控制

注意：TCP 并不能保证数据一定会被对方接收到，因为这是不可能的。TCP 能够做到的是，如果有可能，就把数据递送到接收方，否则就（通过放弃重传并且中断连接这一手段）通知用户。因此准确说 TCP 也不是 100% 可靠的协议，它所能提供的是数据的可靠递送或故障的可靠通知。

##### TCP KeepAlive

TCP 的连接，实际上是一种纯软件层面的概念，在物理层面并没有“连接”这种概念。TCP 通信双方建立交互的连接，但是并不是一直存在数据交互，有些连接会在数据交互完毕后，主动释放连接，而有些不会。在长时间无数据交互的时间段内，交互双方都有可能出现掉电、死机、异常重启等各种意外，当这些意外发生之后，这些 TCP 连接并未来得及正常释放，在软件层面上，连接的另一方并不知道对端的情况，它会一直维护这个连接，长时间的积累会导致非常多的半打开连接，造成端系统资源的消耗和浪费，为了解决这个问题，在传输层可以利用 TCP 的 KeepAlive 机制实现来实现。主流的操作系统基本都在内核里支持了这个特性。

TCP KeepAlive 的基本原理是，隔一段时间给连接对端发送一个探测包，如果收到对方回应的 ACK，则认为连接还是存活的，在超过一定重试次数之后还是没有收到对方的回应，则丢弃该 TCP 连接。

#### UDP 协议

与 TCP 相比，UDP 缺乏可靠性。UDP 本身不提供确认，序列号，超时重传等机制。UDP 数据报可能在网络中被复制，被重新排序。即 UDP 不保证数据报会到达其最终目的地，也不保证各个数据报的先后顺序，也不保证每个数据报只到达一次

#### Socket 基本概念

Socket 是对 TCP/IP 协议族的一种封装，是应用层与 TCP/IP 协议族通信的中间软件抽象层。从设计模式的角度看来，Socket 其实就是一个门面模式，它把复杂的 TCP/IP 协议族隐藏在 Socket 接口后面，对用户来说，一组简单的接口就是全部，让 Socket 去组织数据，以符合指定的协议。

Socket 还可以认为是一种网络间不同计算机上的进程通信的一种方法，利用三元组（ip 地址，协议，端口）就可以唯一标识网络中的进程，网络中的进程通信可以利用这个标志与其它进程进行交互。

Socket 起源于 Unix ，Unix/Linux 基本哲学之一就是“一切皆文件”，都可以用“打开(open) –> 读写(write/read) –> 关闭(close)”模式来进行操作。因此 Socket 也被处理为一种特殊的文件。

#### HTTP 协议

特性

- 构建与 TCP/IP 协议之上，是以一个应用层协议，默认端口 80
- 无连接无状态的

##### HTTP 报文

###### 请求报文(状态行、请求头、消息主体)

HTTP 定义了与服务器交互的不同方法，最基本的方法有 4 种，分别是 GET，POST，PUT，DELETE。URL 全称是资源描述符，我们可以这样认为：一个 URL 地址，它用于描述一个网络上的资源，而 HTTP 中的 GET，POST，PUT，DELETE 就对应着对这个资源的查，增，改，删 4 个操作。

- get:用于信息获取,而且应该是安全，获取信息而非修改信息。一般不产生副作用
- post: 表示可能修改变服务器上的资源的请求。
- get 和 post 区别:
- - GET 可提交的数据量受到 URL 长度的限制，HTTP 协议规范没有对 URL 长度进行限制。这个限制是特定的浏览器及服务器对它的限制
- - 理论上讲，POST 是没有大小限制的，HTTP 协议规范也没有进行大小限制，出于安全考虑，服务器软件在实现时会做一定限制
- - GET 和 POST 数据内容是一模一样的，只是位置不同，一个在 URL 里，一个在 HTTP 包的包体里

###### POST 提交数据的方式

- application/x-www-form-urlencoded(浏览器的原生 form 表单，如果不设置 enctype 属性，那么最终就会以方式提交数据)
- multipart/form-data(使用表单上传文件时,必须让 form 表单的,enctype 等于 multipart/form-data)

##### 响应报文(状态行\响应头\响应正文)

常见的状态码有如下几种:

- 200 OK 客户端请求成功
- 301 Moved Permanently 请求永久重定向
- 302 Moved Temporarily 请求临时重定向
- 304 Not Modified 文件未修改，可以直接使用缓存的文件。
- 400 Bad Request 由于客户端请求有语法错误，不能被服务器所理解。
- 401 Unauthorized 请求未经授权。这个状态代码必须和 WWW-Authenticate 报头域一起使用
- 403 Forbidden 服务器收到请求，但是拒绝提供服务。服务器通常会在响应正文中给出不提供服务的原因
- 404 Not Found 请求的资源不存在，例如，输入了错误的 URL
- 500 Internal Server Error 服务器发生不可预期的错误，导致无法完成客户端的请求。
- 503 Service Unavailable 服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会恢复正常。

#### Cookie 和 Session

1. 什么是会话？
   客户端打开服务器链接请求到服务器响应客户端请求的全过程。
2. 什么是会话跟踪？
   对同一用户对服务器的连续请求和响应进行跟踪
3. 为什么需要会话跟踪？
   因为 HTTP 协议是无状态的协议，不能保存客户信息，如何判断是否是同一个用户呢？这就需要有会话跟踪
4. 常用会话跟踪的方法？

   - Cookie

   是 web 服务器发送给客户端的一小段信息

   客户端可以采用两种方式来保存这个 Cookie 对象，一种方式是保存在客户端内存中，称为临时 Cookie，浏览器关闭后这个 Cookie 对象将消失。另外一种方式是保存在客户机的磁盘上，称为永久 Cookie。以后客户端只要访问该网站，就会将这个 Cookie 再次发送到服务器上，前提是这个 Cookie 在有效期内，这样就实现了对客户的跟踪。

   - Session

   每一个用户都有一个不同的 session，各个用户之间是不能共享的，是每个用户所独享的，在 session 中可以存放信息。

   在服务器端会创建一个 session 对象，产生一个 sessionID 来标识这个 session 对象，然后将这个 sessionID 放入到 Cookie 中 发送到客户端，下一次访问时，sessionID 会发送到服务器，在服务器端进行识别不同的用户。

   Session 的实现依赖于 Cookie，如果 Cookie 被禁用，那么 session 也将失效。

区别总结:

1. session 放在服务端，cookie 放在客户端
2. session 的运行依赖 session ID，而 session ID 存放在 cookie 中，如果 cookie 被禁用，那么 session 也会失效
3. session 可以放在文件、数据库、内存中
