{"./":{"url":"./","title":"简介","keywords":"","body":"简介 分享一下对python的理解 "},"Chapter1.html":{"url":"Chapter1.html","title":"1.数据类型","keywords":"","body":"1.Python数据类型 变量有三问:\"他是谁？他从哪里来？要到哪里去？\" 1.1 可变不可变,有序与无序 可变与不可变实际上是对一个对象进行操作，是否会重新创建一个对象，并将原来的变量重新指向新建的对象，如果没有其他变量引用原来对象的话，原来对象就会被回收 数字(不可变对象) a = 4 #id()获取对象的内存地址 print(id(a)) a +=1 print(a) id(a) 补充:当多个变量值一样的时候 a = 2 b = 2 id(a) id(b) 字符串(不可变,有序对象) a = \"hello\" #print(id(a)) print(a.replace(\"l\",\"w\")) print(a) #print(id(a)) 列表(可变,有序对象) a = ['a','b','c','d'] print(a) # print(id(a)) a[2] = 'eee' print(a) # print(id(a)) 字典(可变,无序对象) d = {'a':\"hello\",'b':\"world\"} # print(id(d)) d['a'] = \"demo\" print(d) # print(id(d)) 元祖(不可变,有序对象) t = (1,2,3,4) print(dir(t)) 因为tuple不可变，所以代码更安全。如果可能，能用tuple代替list就尽量用tuple。 集合(可变,无序,不可重复对象) t = {1,2,3,5,3} print(id(t)) t.add('1212') print(t) print(id(t)) 类型 内容 数字 不可变 str 不可变,有序 list 可变,有序 dict 可变,无序 tuple 不可变,有序 set 可变,无序 1.2 基本数据类型的方法 类型 方法 str center,count,endswith,find,format,index,isalnum,isascii,isdecimal,isdigit,islower,join,lower,replace,split,startswith,strip,title,upper list append,clear,copy,count,extend,index,insert,pop,remove,reverse,sort dict clear,copy,fromkeys,get,items,keys,pop,popitem,setdefault,update,values tuple count,index set add,clear,copy,difference,difference_update,discard,isdisjoint,issubset,issuperset,pop,remove,union,update 查看方法dir(type) strs = 'abcd \\n ef12323' s.index('e') # 查找元素所在位置,不存在会报错 s.find('e') # 查找元素所在位置,不存在是-1 s.startswith('a') # 是否以所传元素开始，bool类型 s.endswith('23) s.splitlines() # 以换行符分割 s.strip('23') # 用于移除字符串头尾指定的字符 s.islower() # 是否小写 s.lower() # 转换成小写 listl = ['a','b','c','d'] l.append('e') l.pop() l.count('c') l.index('b') # 查找元素所在位置,不存在会报错 l.insert(2,'c') l.copy() 1.3 相互转换 转list# 集合转list a = {1,2,3,4,3} print(list(a)) # dict转list d = {'a':'b','c':'d','e':'f'} print(list(d.keys())) # tuple转list t = (1,2,3,4,5) print(list(t)) 转dict# a = [(1,2),(3,4)] a = ((1,2),(3,4)) d = {i:j for i,j in a} 转strs = ['a','b','c','d'] \"\".join(s) 1.4 生成器 直接创建一个很长的列表，会占用很大的内存空间，有没有一种方法一边循环一边计算的机制，这样的机制叫生成器(generator) l = [x for x in range(15)] g = (x for x in range(15)) 生成器不但可以作用于for循环，还可以被next()函数不断调用并返回下一个值，直到最后抛出StopIteration错误表示无法继续返回下一个值 next(g) def odd(): print('step 1') yield 1 print('step 2') yield(3) print('step 3') yield(5) o = odd() def gener(): for i in range(5): yield i print(i) # if i==3: # return i for j in gener(): print(j) def foo(num): print('start......') while True: res = yield 4 print(\"res:\" res) g =foo() print(next(g)) print('-'*20) # print(g.send(7)) print(next(g)) 此时foo就是一个生成器函数,next就相当于“下一步”生成哪个数，这一次的next开始的地方是接着上一次的next停止的地方执行的，所以调用next的时候，生成器并不会从foo函数的开始执行，只是接着上一步停止的地方开始，然后遇到yield后，return出要生成的数，此步就结束。 1.5 迭代器 list,tuple,dict,str,set,生成器,yield 直接作用于for循环的统称可迭代对象Iterable 可以被next()函数调用并不断返回下一个值的对象称为迭代器：迭代器Iterator 凡是可作用于for循环的对象都是Iterable类型 凡是可作用于next()函数的对象都是Iterator类型 1.6 示例 ss ='{}'.format('(\"'+str(tuple(df_2['学员编号'])[0])+'\")' if df_2['学员编号'].shape[0] == 1 else tuple(str(x) for x in tuple(df_2['学员编号']))) tt = '({})'.format(\",\".join(df_2['学员编号'].tolist())) sql_ks = ''' select stats_date, is_leader, ul.name, replace(fifth_level,'考核组','') department from will_user_list_keguan_all ul left join will_department_list dl on dl.id = ul.department_id where first_level = '客户关系中心' and stats_date >= '{0}' and stats_date def response_df_format(resp): res = [] for i in resp: for k, v in i.items(): if str(v) in [\"nan\", \"NaT\", \"None\",\"null\"]: i[k] = None if isinstance(v, datetime): i[k] = datetime.strftime(v, \"%Y-%m-%d %H:%M\") elif isinstance(v, date): i[k] = datetime.strftime(v, \"%Y-%m-%d\") res.append(i) return res 遍历一个集合及其下标 colors = ['red','green','blue','yellow'] for i in range(len(colors)): print(i,colors[i]) for i, color in enumerate(colors): print(i,color) 遍历两个集合 names = ['raymond', 'rachel', 'matthew'] colors = ['red', 'green', 'blue', 'yellow'] n = min(len(names), len(colors)) for i in range(n): print names[i], '--->', colors[i] for name, color in zip(names, colors): print name, '--->', color 在循环内识别多个退出点 def find(seq, target): found = False for i, value in enumerate(seq): if value == target: found = True break if not found: return -1 return i def find(seq, target): for i, value in enumerate(seq): if value == target: break else: return -1 return i 用字典计数 colors = ['red', 'green', 'red', 'blue', 'green', 'red'] # 简单，基本的计数方法。适合初学者起步时学习。 d = {} for color in colors: if color not in d: d[color] = 0 d[color] += 1 d = {} for color in colors: d[color] = d.get(color, 0) + 1 更新多个变量的状态 def fibonacci(n): x = 0 y = 1 for i in range(n): t = y y = x + y x = t def fibonacci(n): x, y = 0, 1 for i in range(n): x, y = y, x + y "},"Chapter2.html":{"url":"Chapter2.html","title":"2.面向对象","keywords":"","body":"2.Python面向对象 2.1:面向对象 面向过程:把函数切分为子函数，即把大块函数通过切割成小块函数来降低系统的复杂度. 面向对象:把计算机程序视为一组对象的集合，而每个对象都可以接收其他对象发过来的消息，并处理这些消息 可以对现实事物、问题进行抽象编程,把对象作为程序的基本单元，一个对象包含了数据和操作数据的函数。 std1 = { 'name': 'Michael', 'score': 98 } std2 = { 'name': 'Bob', 'score': 81 } def print_score(std): print('%s: %s' % (std['name'], std['score'])) class Student(object): def __init__(self, name, score): self.name = name self.score = score def print_score(self): print('%s: %s' % (self.name, self.score)) bart = Student('Bart Simpson', 59) lisa = Student('Lisa Simpson', 87) bart.print_score() lisa.print_score() 我们定义的Class——Student，是指学生这个概念，而实例（Instance）则是一个个具体的Student，比如，Bart Simpson和Lisa Simpson是两个具体的Student。 面向对象的设计思想是抽象出Class，根据Class创建Instance。 面向对象的抽象程度又比函数要高，因为一个Class既包含数据，又包含操作数据的方法。 2.2:类属性和实例属性 class Student(object): #self指代是对象本身,代表当前对象的地址 #self表示当前实例化对象 def __init__(self, name, score): self.name = name self.score = score def get_grade(self): if self.score >= 90: return 'A' elif self.score >= 60: return 'B' else: return 'C' lisa = Student('Lisa', 99) bart = Student('Bart', 59) print(lisa.name, lisa.get_grade()) print(bart.name, bart.get_grade()) class S(object): name = \"sss\" class S(object): def __init__(self): self.name = \"sss\" class T(object): name = \"hello\" def b(self): self.name = \"world\" def h(self): print(name) # print(self.name) 千万不要对实例属性和类属性使用相同的名字，因为相同名称的实例属性将屏蔽掉类属性，但是当你删除实例属性后，再使用相同的名称，访问到的将是类属性。 类是创建实例的模板，而实例则是一个一个具体的对象，各个实例拥有的数据都互相独立，互不影响； 方法就是与实例绑定的函数，和普通函数不同，方法可以直接访问实例的数据； 通过在实例上调用方法，我们就直接操作了对象内部的数据，但无需知道方法内部的实现细节。 2.3:静态方法和类方法 实例方法 class Dog(object): def __init__(self,name): self.name = name def eat(self,food): print(\"%s is eating %s\"%(self.name,food)) d = Dog(\"GOU\") d.eat(\"GUTOU\") 静态方法 class Dog(object): hello = \"xxxx\" def __init__(self,name): self.name = name @staticmethod def eat(): print(\"%s is eating %s\"%(\"name\",\"tt\")) print(hello) # print(self.name) d = Dog(\"GOU\") d.eat() Dog.eat() 当eat函数变为静态方法时，此时静态方法将eat函数与类Dog之间的关联截断，之前调用类下面的方法会自动传self，如果用了staticmethod，那么就可以无视这个self，而将这个方法当成一个普通的函数使用。 静态方法是个独立的、单纯的函数，它仅仅托管于某个类的名称空间中，便于使用和维护,不能访问实例变量和类属性 类方法 class Dog(object): hello = \"hello\" def __init__(self,name): self.name = name @classmethod def eat(cls): cls.h=\"hello\" print(\"%s is eating %s\"%(cls.h,\"xx\")) print(cls.hello) # print(self.name) d = Dog(\"Gou\") d.eat() Dog.eat() 类方法是将类本身作为对象进行操作的方法。类方法只能访问类变量，不能访问实例变量。 属性 方法 实例方法 可以用类方法和静态方法,但不建议 静态方法 不能访问实例方法和类方法 类方法 能访问类属性,不能访问实例属性和方法 三大特点:数据封装、继承和多态 2.4:继承和多态 继承 class Animal(object): def run(self): print('Animal is running...') class Dog(Animal): pass class Cat(Animal): pass dog = Dog() dog.run() cat = Cat() cat.run() 多态 def run_twice(animal): animal.run() animal.run() run_twice(Animal()) run_twice(Dog()) run_twice(Cat()) class Tortoise(Animal): def run(self): print('Tortoise is running slowly...') run_twice(Tortoise()) 新增一个Animal的子类，不必对run_twice()做任何修改，实际上，任何依赖Animal作为参数的函数或者方法都可以不加修改地正常运行，原因就在于多态. 多态的好处就是，当我们需要传入Dog、Cat、Tortoise……时，我们只需要接收Animal类型就可以了，因为Dog、Cat、Tortoise……都是Animal类型，然后，按照Animal类型进行操作即可。由于Animal类型有run()方法，因此，传入的任意类型，只要是Animal类或者子类，就会自动调用实际类型的run()方法. 对扩展开放,对修改封闭 2.5:魔法方法 构造和初始化 init初始化对象时使用，定义这个对象的初始值class Person(object): def __init__(self,name,age): self.name = name self.age = age p = Person('Lisa',18) new创建实例化对象时调用,他是对象实例化时第一个被调用，然后再调用init# 单例模式 class Singleton(object): _instance = None def __new__(cls,*args,**kwargs): if not cls._instance: cls._instance = super(Singleton,cls).__new__(cls,*args,**kwargs) return cls._instance class MySingleton(Singleton): pass a = MySingleton() b = MySingleton() a.values = \"2343\" print(b.values) print(a is b) # 使用场景是当你需要继承内置类时，例如int、str、tuple，只能通过__new__来达到初始化数据的效果 class g(int): def __init__(self,value): super(g,self).__init__(self,abs(value)) class g(int): def __new__(cls,value): return float.__new__(cls,abs(value)) a = g(-23) print(a) del在对象被垃圾回收时才被调用，del x不一定会执行此方法。class Person(object): def __del__(self): print('__del__',self) a = Person() del a c = Person() d = c del c 类的表示 str强调可读性,repr强调准确性/标准性class Person(object): def __init__(self,name,age): self.name=name self.age=age def __str__(self): return 'name:%s,age:%s' % (self.name,self.age) def __repr__(self): return \"Person('%s',%s)\" %(self.name,self.age) person = Person('zhang',23) print(str(person)) print( '%s'%person) print(repr(person)) print('%r'%person) 访问控制 setattr设置属性 getattr访问不存在的属性 delattr删除某个属性 getattribute访问任意属性或方法 class Person(object): def __setattr__(self, key, value): \"\"\"属性赋值\"\"\" if key not in ('name', 'age'): return if key == 'age' and value call将类实例对象变成可调用对象class X(object): def __call__(self): return 40 x = X() x(10) enter/exit 上下文管理class O(object): def __init__(self,name): print(name) self.name = name def __enter__(self): print('__enter__') return self def __exit__(self,exc_type,exc_val,exc_tb): print('__exit__') with O('hello') as o: o.name 2.6:元类(metaclass创建类的模版) 先定义metaclass，就可以创建类，最后创建实例。 type()又可以创建新的类型class Hello(object): def hello(self,name=\"world\"): print(name) h = Hello() h.hello() print(type(Hello)) print(type(h)) def fn(self,name=\"world\"): print(name) Hello = type('Hello',(object,),dict(hello=fn)) h = Hello() h.hello() print(type(Hello)) print(type(h)) 创建一个自定义的元类,必须是继承type的class ListMetaclass(type): def __new__(cls, name, bases, attrs): attrs['add'] = lambda self, value: self.append(value) return type.__new__(cls, name, bases, attrs) class MyList(list,metaclass=ListMetaclass): pass L = MyList() L.add(1) print(L) print(type(L)) 2.7:Python中的type 和 object 参考链接 --CSDN-- "},"Chapter3.html":{"url":"Chapter3.html","title":"3.闭包+上下文管理","keywords":"","body":"python闭包 闭包：python中一切皆对象,函数也是对象.当某个函数被当成对象返回时,并且内函数里运用了外函数的临时变量,就形成类一个闭包 def hello(): a = 'hello' def app(): print('hello') return app 判断一个函数是否是一个闭包函数时调用他的closure属性,返回不为空的元祖就是一个闭包函数 # 外部函数 def outer(a): b = 20 # a,b外函数的临时变量 # 内函数 def inner(): # 在函数中调用了外函数的临时变量 print(a+b) # 返回内函数的引用 return inner a = outer(5) a() 在闭包内函数中，我们可以随意使用外函数的临时变量,那么我们可以修改吗？ 在python中如何修改全局变量 a = \"abcdefg\" def test(): global a a = \"123456\" test() print(a) l = ['a','b','c'] def test(): l[0]=['0000'] test() print(l) 1.用global声明(不可变类型) 2.如果是可变类型的话可以直接修改 def outer(): a = 10 b = [123] def inner(): nonlocal a a +=1 b[0] +=10 print(a,b) return inner a = outer() a() python3中可以用nonlocal声明,表示这个变量不是局部变量空间的变量，需要向上一层变量空间找这个变量。 def outer(x): def inner(y): nonlocal x print(x,y) return inner a = outer(20) a(10) a(12) 每次调用内函数都在使用同一份闭包变量 应用场景 装饰器def log(func): def wrapper(*args,**kw): print(\"write_log\") return func(*args,**kw) return wrapper @log def h(): print('test') h() # log(h).__closure__ 装饰器执行顺序 def a(f): print('enter a') def wrapper(*args,**kw): print('execute a') return f(*args,**kw) return wrapper def b(f): print('enter b') def wrapper(*args,**kw): print('execute b') return f(*args,**kw) return wrapper @a @b def log(): print('write_log') log() # a(b(log))() 面向对象编程 闭包可以把闭包变量给内函数，类创建的对象具有相同的属性和方法，所以闭包也是实现面向对象的方法之一def line_conf(a,b): def line(x): return a*x+b return line l = line_conf(2,3) y = l(5) y = l(6) class Line(object): def __init__(self,a,b): self.a = a self.b = b def get_y(self,x): return self.a*x+self.b l = Line(2,3) y = l.get_y(5) y = l.get_y(6) 相对于这种单方法类，使用闭包会显得更加简洁和优雅一些。 上下文管理(代码块执行前准备,执行后收拾) 上下文管理协议:包含方法 enter() 和 exit()，支持该协议的对象要实现这两个方法 上下文管理器:定义执行 with 语句时要建立的运行时上下文，负责执行 with 语句块上下文中的进入与退出操作。通常使用 with 语句调用上下文管理器，也可以通过直接调用其方法来使用。 创建上下文管理器的方法 class O(object): def __init__(self,name): print(name) self.name = name def __enter__(self): print('__enter__') return self def __exit__(self,exc_type,exc_val,exc_tb): print('__exit__') with O('hello') as o: o.name # 上下文管理工具 from contextlib import contextmanager @contextmanager def demo(): print ('executes in __enter__') yield '*** contextmanager demo ***' print ('executes in __exit__') with demo() as value: print ('Assigned Value: %s' % value) 应用场景,主要应用与资源创建与释放，比如:数据库的连接，查询，关闭处理\\文件的打开和关闭 class Database(object): def __init__(self): self.connected = False def connect(self): self.connected = True def close(self): self.connected = False def query(self): if self.connected: return 'query data' else: raise ValueError('DB not connected ') def handle_query(): db = Database() db.connect() print ('handle --- ', db.query()) db.close() handle_query() class Database(object): def __init__(self): self.connected = False def __enter__(self): self.connected = True print(self.connected) return self def __exit__(self,*args): self.connected = False print(self.connected) def query(self): if self.connected: print( 'query data') else: raise ValueError('DB not connected ') with Database() as db: db.query() "},"Chapter4.html":{"url":"Chapter4.html","title":"4.python练习","keywords":"","body":"python练习题 在屏幕上显示跑马灯文字import os import time def marquee(): content = '北京欢迎你为你开天辟地…………' while True: os.system('clear') print(content) time.sleep(0.2) content = content[1:] + content[0] marquee() 设计一个函数产生指定长度的验证码，验证码由大小写字母和数字构成。import random import string def captcha(n=4): source = list(string.ascii_letters) source.extend(map(lambda x: str(x), range(0, 10))) return \"\".join(random.sample(source, n)) print(captcha(6)) 计算指定的年月日是这一年的第几天def is_leap_year(year): return year % 4 == 0 and year % 100 != 0 or year % 400 == 0 def which_day(year, month, date): days_of_month = [ [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31] ][is_leap_year(year)] total = 0 for index in range(month - 1): total += days_of_month[index] return total + date print(which_day(2019,12,31)) import pandas as pd def which_day2(s): d = pd.to_datetime(s,\"coerce\") if str(d)=='NaT': return \"\" return d.dayofyear print(which_day2('2019-12-12')) 设计一个函数返回给定文件名的后缀名。def get_filename(name): res = name.rsplit(\".\",1) return \"\" if len(res)==1 else res[-1] name=\"helrkjelr.xls\" print(get_filename(name)) 设计一个函数返回时针与分针的夹角。def times(h,m): return abs(((h+m//12)*5-m)*6) 有效括号#给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。 #有效字符串需满足： # 左括号必须用相同类型的右括号闭合。 # 左括号必须以正确的顺序闭合。 # 注意空字符串可被认为是有效字符串。 def isValid1(s): d = {')':'(',']':'[','}':'{'} stack = [None] for i in s: if i in d and d[i]==stack[-1]: stack.pop() else: stack.append(i) return len(stack)==1 s = \"()()()\" print(isValid1(s)) def isValid2(s): while '{}' in s or '()' in s or '[]' in s: s = s.replace('{}', '') s = s.replace('[]', '') s = s.replace('()', '') return s == '' 面向对象编程 定义一个类描述平面上的点并提供移动点和计算到另一个点距离的方法。from math import sqrt class Point(object): def __init__(self, x=0, y=0): self.x = x self.y = y def move_to(self, x, y): self.x = x self.y = y def move_by(self, dx, dy): self.x += dx self.y += dy def distance_to(self, other): dx = self.x - other.x dy = self.y - other.y return sqrt(dx ** 2 + dy ** 2) def __str__(self): return '(%s, %s)' % (str(self.x), str(self.y)) p1 = Point(3, 5) p2 = Point() print(p1) print(p2) p2.move_by(-1, 2) print(p2) print(p1.distance_to(p2)) 工资结算系统# 某公司有三种类型的员工 分别是部门经理、程序员和销售员需要设计一个工资结算系统 # 根据提供的员工信息来计算月薪 # 部门经理的月薪是每月固定15000元 # 程序员的月薪按本月工作时间计算 每小时150元 # 销售员的月薪是1200元的底薪加上销售额5%的提成 class Employee(object): def __init__(self,name): self._name = name def name(self): return self._name def get_salary(self): pass class Manager(Employee): def get_salary(self): return 15000.0 class Programmer(Employee): def __init__(self,name,hour=0): super().__init__(name) self._working_hour = hour def working_hour(self,hour): self._working_hour = hour def get_salary(self): return 150.0*self._working_hour class Salesman(Employee): def __init__(self,name,sales=0): super().__init__(name) self._sales = sales def sales(self,sales): self._sales = sales def get_salary(self): return 1200.0 +self._sales*0.05 emps = [Manager('a'),Programmer('b'),Salesman('c')] for emp in emps: if isinstance(emp,Programmer): emp.working_hour(int(input('%s'% emp.name()))) elif isinstance(emp,Salesman): emp.sales(float(input('%s'% emp.name()))) print(emp.name(),emp.get_salary()) "},"Chapter5.html":{"url":"Chapter5.html","title":"5.异步编程","keywords":"","body":"同步与异步 多线程 线程是最小的执行单元，一个进程由至少一个线程组成，这个线程加主线程 import threading def loop(): n = 0 while n 多进程 协程 "},"Chapter6.html":{"url":"Chapter6.html","title":"6.数据结构之排序","keywords":"","body":"算法分析 参考链接python数据结构 冒泡排序 选择排序 插入排序 希尔排序 归并排序 快速排序 对比 "},"Chapter7.html":{"url":"Chapter7.html","title":"7.链表/栈/队列","keywords":"","body":"链表 栈 队列 "}}