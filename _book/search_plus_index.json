{"./":{"url":"./","title":"简介","keywords":"","body":"简介 分享一下对python的理解 "},"python/chapter1.html":{"url":"python/chapter1.html","title":"数据类型","keywords":"","body":"Python数据类型 变量有三问:\"他是谁？他从哪里来？要到哪里去？\" 1.1 可变不可变,有序与无序 可变与不可变实际上是对一个对象进行操作，是否会重新创建一个对象，并将原来的变量重新指向新建的对象，如果没有其他变量引用原来对象的话，原来对象就会被回收 数字(不可变对象) a = 4 #id()获取对象的内存地址 print(id(a)) a +=1 print(a) id(a) 补充:当多个变量值一样的时候 a = 2 b = 2 id(a) id(b) 字符串(不可变,有序对象) a = \"hello\" #print(id(a)) print(a.replace(\"l\",\"w\")) print(a) #print(id(a)) 列表(可变,有序对象) a = ['a','b','c','d'] print(a) # print(id(a)) a[2] = 'eee' print(a) # print(id(a)) 字典(可变,无序对象) d = {'a':\"hello\",'b':\"world\"} # print(id(d)) d['a'] = \"demo\" print(d) # print(id(d)) 元祖(不可变,有序对象) t = (1,2,3,4) print(dir(t)) 因为tuple不可变，所以代码更安全。如果可能，能用tuple代替list就尽量用tuple。 集合(可变,无序,不可重复对象) t = {1,2,3,5,3} print(id(t)) t.add('1212') print(t) print(id(t)) 类型 内容 数字 不可变 str 不可变,有序 list 可变,有序 dict 可变,无序 tuple 不可变,有序 set 可变,无序 1.2 基本数据类型的方法 类型 方法 str center,count,endswith,find,format,index,isalnum,isascii,isdecimal,isdigit,islower,join,lower,replace,split,startswith,strip,title,upper list append,clear,copy,count,extend,index,insert,pop,remove,reverse,sort dict clear,copy,fromkeys,get,items,keys,pop,popitem,setdefault,update,values tuple count,index set add,clear,copy,difference,difference_update,discard,isdisjoint,issubset,issuperset,pop,remove,union,update 查看方法dir(type) strs = 'abcd \\n ef12323' s.index('e') # 查找元素所在位置,不存在会报错 s.find('e') # 查找元素所在位置,不存在是-1 s.startswith('a') # 是否以所传元素开始，bool类型 s.endswith('23) s.splitlines() # 以换行符分割 s.strip('23') # 用于移除字符串头尾指定的字符 s.islower() # 是否小写 s.lower() # 转换成小写 listl = ['a','b','c','d'] l.append('e') l.pop() l.count('c') l.index('b') # 查找元素所在位置,不存在会报错 l.insert(2,'c') l.copy() 1.3 相互转换 转list# 集合转list a = {1,2,3,4,3} print(list(a)) # dict转list d = {'a':'b','c':'d','e':'f'} print(list(d.keys())) # tuple转list t = (1,2,3,4,5) print(list(t)) 转dict# a = [(1,2),(3,4)] a = ((1,2),(3,4)) d = {i:j for i,j in a} 转strs = ['a','b','c','d'] \"\".join(s) 1.4 生成器 直接创建一个很长的列表，会占用很大的内存空间，有没有一种方法一边循环一边计算的机制，这样的机制叫生成器(generator) l = [x for x in range(15)] g = (x for x in range(15)) 生成器不但可以作用于for循环，还可以被next()函数不断调用并返回下一个值，直到最后抛出StopIteration错误表示无法继续返回下一个值 next(g) def odd(): print('step 1') yield 1 print('step 2') yield(3) print('step 3') yield(5) o = odd() def gener(): for i in range(5): yield i print(i) # if i==3: # return i for j in gener(): print(j) def foo(num): print('start......') while True: res = yield 4 print(\"res:\" res) g =foo() print(next(g)) print('-'*20) # print(g.send(7)) print(next(g)) 此时foo就是一个生成器函数,next就相当于“下一步”生成哪个数，这一次的next开始的地方是接着上一次的next停止的地方执行的，所以调用next的时候，生成器并不会从foo函数的开始执行，只是接着上一步停止的地方开始，然后遇到yield后，return出要生成的数，此步就结束。 1.5 迭代器 list,tuple,dict,str,set,生成器,yield 直接作用于for循环的统称可迭代对象Iterable 可以被next()函数调用并不断返回下一个值的对象称为迭代器：迭代器Iterator 凡是可作用于for循环的对象都是Iterable类型 凡是可作用于next()函数的对象都是Iterator类型 1.6 示例 ss ='{}'.format('(\"'+str(tuple(df_2['学员编号'])[0])+'\")' if df_2['学员编号'].shape[0] == 1 else tuple(str(x) for x in tuple(df_2['学员编号']))) tt = '({})'.format(\",\".join(df_2['学员编号'].tolist())) sql_ks = ''' select stats_date, is_leader, ul.name, replace(fifth_level,'考核组','') department from will_user_list_keguan_all ul left join will_department_list dl on dl.id = ul.department_id where first_level = '客户关系中心' and stats_date >= '{0}' and stats_date def response_df_format(resp): res = [] for i in resp: for k, v in i.items(): if str(v) in [\"nan\", \"NaT\", \"None\",\"null\"]: i[k] = None if isinstance(v, datetime): i[k] = datetime.strftime(v, \"%Y-%m-%d %H:%M\") elif isinstance(v, date): i[k] = datetime.strftime(v, \"%Y-%m-%d\") res.append(i) return res 遍历一个集合及其下标 colors = ['red','green','blue','yellow'] for i in range(len(colors)): print(i,colors[i]) for i, color in enumerate(colors): print(i,color) 遍历两个集合 names = ['raymond', 'rachel', 'matthew'] colors = ['red', 'green', 'blue', 'yellow'] n = min(len(names), len(colors)) for i in range(n): print names[i], '--->', colors[i] for name, color in zip(names, colors): print name, '--->', color 在循环内识别多个退出点 def find(seq, target): found = False for i, value in enumerate(seq): if value == target: found = True break if not found: return -1 return i def find(seq, target): for i, value in enumerate(seq): if value == target: break else: return -1 return i 用字典计数 colors = ['red', 'green', 'red', 'blue', 'green', 'red'] # 简单，基本的计数方法。适合初学者起步时学习。 d = {} for color in colors: if color not in d: d[color] = 0 d[color] += 1 d = {} for color in colors: d[color] = d.get(color, 0) + 1 更新多个变量的状态 def fibonacci(n): x = 0 y = 1 for i in range(n): t = y y = x + y x = t def fibonacci(n): x, y = 0, 1 for i in range(n): x, y = y, x + y "},"python/chapter2.html":{"url":"python/chapter2.html","title":"面向对象","keywords":"","body":"Python面向对象 面向对象 面向过程:把函数切分为子函数，即把大块函数通过切割成小块函数来降低系统的复杂度. 面向对象:把计算机程序视为一组对象的集合，而每个对象都可以接收其他对象发过来的消息，并处理这些消息 可以对现实事物、问题进行抽象编程,把对象作为程序的基本单元，一个对象包含了数据和操作数据的函数。 std1 = { 'name': 'Michael', 'score': 98 } std2 = { 'name': 'Bob', 'score': 81 } def print_score(std): print('%s: %s' % (std['name'], std['score'])) class Student(object): def __init__(self, name, score): self.name = name self.score = score def print_score(self): print('%s: %s' % (self.name, self.score)) bart = Student('Bart Simpson', 59) lisa = Student('Lisa Simpson', 87) bart.print_score() lisa.print_score() 我们定义的Class——Student，是指学生这个概念，而实例（Instance）则是一个个具体的Student，比如，Bart Simpson和Lisa Simpson是两个具体的Student。 面向对象的设计思想是抽象出Class，根据Class创建Instance。 面向对象的抽象程度又比函数要高，因为一个Class既包含数据，又包含操作数据的方法。 类属性和实例属性 class Student(object): #self指代是对象本身,代表当前对象的地址 #self表示当前实例化对象 def __init__(self, name, score): self.name = name self.score = score def get_grade(self): if self.score >= 90: return 'A' elif self.score >= 60: return 'B' else: return 'C' lisa = Student('Lisa', 99) bart = Student('Bart', 59) print(lisa.name, lisa.get_grade()) print(bart.name, bart.get_grade()) class S(object): name = \"sss\" class S(object): def __init__(self): self.name = \"sss\" class T(object): name = \"hello\" def b(self): self.name = \"world\" def h(self): print(name) # print(self.name) 千万不要对实例属性和类属性使用相同的名字，因为相同名称的实例属性将屏蔽掉类属性，但是当你删除实例属性后，再使用相同的名称，访问到的将是类属性。 类是创建实例的模板，而实例则是一个一个具体的对象，各个实例拥有的数据都互相独立，互不影响； 方法就是与实例绑定的函数，和普通函数不同，方法可以直接访问实例的数据； 通过在实例上调用方法，我们就直接操作了对象内部的数据，但无需知道方法内部的实现细节。 静态方法和类方法 实例方法 class Dog(object): def __init__(self,name): self.name = name def eat(self,food): print(\"%s is eating %s\"%(self.name,food)) d = Dog(\"GOU\") d.eat(\"GUTOU\") 静态方法 class Dog(object): hello = \"xxxx\" def __init__(self,name): self.name = name @staticmethod def eat(): print(\"%s is eating %s\"%(\"name\",\"tt\")) print(hello) # print(self.name) d = Dog(\"GOU\") d.eat() Dog.eat() 当eat函数变为静态方法时，此时静态方法将eat函数与类Dog之间的关联截断，之前调用类下面的方法会自动传self，如果用了staticmethod，那么就可以无视这个self，而将这个方法当成一个普通的函数使用。 静态方法是个独立的、单纯的函数，它仅仅托管于某个类的名称空间中，便于使用和维护,不能访问实例变量和类属性 类方法 class Dog(object): hello = \"hello\" def __init__(self,name): self.name = name @classmethod def eat(cls): cls.h=\"hello\" print(\"%s is eating %s\"%(cls.h,\"xx\")) print(cls.hello) # print(self.name) d = Dog(\"Gou\") d.eat() Dog.eat() 类方法是将类本身作为对象进行操作的方法。类方法只能访问类变量，不能访问实例变量。 属性 方法 实例方法 可以用类方法和静态方法,但不建议 静态方法 不能访问实例方法和类方法 类方法 能访问类属性,不能访问实例属性和方法 三大特点:数据封装、继承和多态 继承和多态 继承 class Animal(object): def run(self): print('Animal is running...') class Dog(Animal): pass class Cat(Animal): pass dog = Dog() dog.run() cat = Cat() cat.run() 多态 def run_twice(animal): animal.run() animal.run() run_twice(Animal()) run_twice(Dog()) run_twice(Cat()) class Tortoise(Animal): def run(self): print('Tortoise is running slowly...') run_twice(Tortoise()) 新增一个Animal的子类，不必对run_twice()做任何修改，实际上，任何依赖Animal作为参数的函数或者方法都可以不加修改地正常运行，原因就在于多态. 多态的好处就是，当我们需要传入Dog、Cat、Tortoise……时，我们只需要接收Animal类型就可以了，因为Dog、Cat、Tortoise……都是Animal类型，然后，按照Animal类型进行操作即可。由于Animal类型有run()方法，因此，传入的任意类型，只要是Animal类或者子类，就会自动调用实际类型的run()方法. 对扩展开放,对修改封闭 魔法方法 构造和初始化 init初始化对象时使用，定义这个对象的初始值class Person(object): def __init__(self,name,age): self.name = name self.age = age p = Person('Lisa',18) new创建实例化对象时调用,他是对象实例化时第一个被调用，然后再调用init# 单例模式 class Singleton(object): _instance = None def __new__(cls,*args,**kwargs): if not cls._instance: cls._instance = super(Singleton,cls).__new__(cls,*args,**kwargs) return cls._instance class MySingleton(Singleton): pass a = MySingleton() b = MySingleton() a.values = \"2343\" print(b.values) print(a is b) # 使用场景是当你需要继承内置类时，例如int、str、tuple，只能通过__new__来达到初始化数据的效果 class g(int): def __init__(self,value): super(g,self).__init__(self,abs(value)) class g(int): def __new__(cls,value): return float.__new__(cls,abs(value)) a = g(-23) print(a) del在对象被垃圾回收时才被调用，del x不一定会执行此方法。class Person(object): def __del__(self): print('__del__',self) a = Person() del a c = Person() d = c del c 类的表示 str强调可读性,repr强调准确性/标准性class Person(object): def __init__(self,name,age): self.name=name self.age=age def __str__(self): return 'name:%s,age:%s' % (self.name,self.age) def __repr__(self): return \"Person('%s',%s)\" %(self.name,self.age) person = Person('zhang',23) print(str(person)) print( '%s'%person) print(repr(person)) print('%r'%person) 访问控制 setattr设置属性 getattr访问不存在的属性 delattr删除某个属性 getattribute访问任意属性或方法 class Person(object): def __setattr__(self, key, value): \"\"\"属性赋值\"\"\" if key not in ('name', 'age'): return if key == 'age' and value call将类实例对象变成可调用对象class X(object): def __call__(self): return 40 x = X() x(10) enter/exit 上下文管理class O(object): def __init__(self,name): print(name) self.name = name def __enter__(self): print('__enter__') return self def __exit__(self,exc_type,exc_val,exc_tb): print('__exit__') with O('hello') as o: o.name 元类(metaclass创建类的模版) 先定义metaclass，就可以创建类，最后创建实例。 type()又可以创建新的类型class Hello(object): def hello(self,name=\"world\"): print(name) h = Hello() h.hello() print(type(Hello)) print(type(h)) def fn(self,name=\"world\"): print(name) Hello = type('Hello',(object,),dict(hello=fn)) h = Hello() h.hello() print(type(Hello)) print(type(h)) 创建一个自定义的元类,必须是继承type的class ListMetaclass(type): def __new__(cls, name, bases, attrs): attrs['add'] = lambda self, value: self.append(value) return type.__new__(cls, name, bases, attrs) class MyList(list,metaclass=ListMetaclass): pass L = MyList() L.add(1) print(L) print(type(L)) Python中的type 和 object 参考链接 CSDN "},"python/chapter3.html":{"url":"python/chapter3.html","title":"闭包+上下文管理","keywords":"","body":"python闭包 闭包：python中一切皆对象,函数也是对象.当某个函数被当成对象返回时,并且内函数里运用了外函数的临时变量,就形成类一个闭包 def hello(): a = 'hello' def app(): print('hello') return app 判断一个函数是否是一个闭包函数时调用他的closure属性,返回不为空的元祖就是一个闭包函数 # 外部函数 def outer(a): b = 20 # a,b外函数的临时变量 # 内函数 def inner(): # 在函数中调用了外函数的临时变量 print(a+b) # 返回内函数的引用 return inner a = outer(5) a() 在闭包内函数中，我们可以随意使用外函数的临时变量,那么我们可以修改吗？ 在python中如何修改全局变量 a = \"abcdefg\" def test(): global a a = \"123456\" test() print(a) l = ['a','b','c'] def test(): l[0]=['0000'] test() print(l) 1.用global声明(不可变类型) 2.如果是可变类型的话可以直接修改 def outer(): a = 10 b = [123] def inner(): nonlocal a a +=1 b[0] +=10 print(a,b) return inner a = outer() a() python3中可以用nonlocal声明,表示这个变量不是局部变量空间的变量，需要向上一层变量空间找这个变量。 def outer(x): def inner(y): nonlocal x print(x,y) return inner a = outer(20) a(10) a(12) 每次调用内函数都在使用同一份闭包变量 应用场景 装饰器def log(func): def wrapper(*args,**kw): print(\"write_log\") return func(*args,**kw) return wrapper @log def h(): print('test') h() # log(h).__closure__ 装饰器执行顺序 def a(f): print('enter a') def wrapper(*args,**kw): print('execute a') return f(*args,**kw) return wrapper def b(f): print('enter b') def wrapper(*args,**kw): print('execute b') return f(*args,**kw) return wrapper @a @b def log(): print('write_log') log() # a(b(log))() 面向对象编程 闭包可以把闭包变量给内函数，类创建的对象具有相同的属性和方法，所以闭包也是实现面向对象的方法之一def line_conf(a,b): def line(x): return a*x+b return line l = line_conf(2,3) y = l(5) y = l(6) class Line(object): def __init__(self,a,b): self.a = a self.b = b def get_y(self,x): return self.a*x+self.b l = Line(2,3) y = l.get_y(5) y = l.get_y(6) 相对于这种单方法类，使用闭包会显得更加简洁和优雅一些。 上下文管理(代码块执行前准备,执行后收拾) 上下文管理协议:包含方法 enter() 和 exit()，支持该协议的对象要实现这两个方法 上下文管理器:定义执行 with 语句时要建立的运行时上下文，负责执行 with 语句块上下文中的进入与退出操作。通常使用 with 语句调用上下文管理器，也可以通过直接调用其方法来使用。 创建上下文管理器的方法 class O(object): def __init__(self,name): print(name) self.name = name def __enter__(self): print('__enter__') return self def __exit__(self,exc_type,exc_val,exc_tb): print('__exit__') with O('hello') as o: o.name # 上下文管理工具 from contextlib import contextmanager @contextmanager def demo(): print ('executes in __enter__') yield '*** contextmanager demo ***' print ('executes in __exit__') with demo() as value: print ('Assigned Value: %s' % value) 应用场景,主要应用与资源创建与释放，比如:数据库的连接，查询，关闭处理\\文件的打开和关闭 class Database(object): def __init__(self): self.connected = False def connect(self): self.connected = True def close(self): self.connected = False def query(self): if self.connected: return 'query data' else: raise ValueError('DB not connected ') def handle_query(): db = Database() db.connect() print ('handle --- ', db.query()) db.close() handle_query() class Database(object): def __init__(self): self.connected = False def __enter__(self): self.connected = True print(self.connected) return self def __exit__(self,*args): self.connected = False print(self.connected) def query(self): if self.connected: print( 'query data') else: raise ValueError('DB not connected ') with Database() as db: db.query() "},"python/chapter4.html":{"url":"python/chapter4.html","title":"python练习","keywords":"","body":"python练习题 在屏幕上显示跑马灯文字import os import time def marquee(): content = '北京欢迎你为你开天辟地…………' while True: os.system('clear') print(content) time.sleep(0.2) content = content[1:] + content[0] marquee() 设计一个函数产生指定长度的验证码，验证码由大小写字母和数字构成。import random import string def captcha(n=4): source = list(string.ascii_letters) source.extend(map(lambda x: str(x), range(0, 10))) return \"\".join(random.sample(source, n)) print(captcha(6)) 计算指定的年月日是这一年的第几天def is_leap_year(year): return year % 4 == 0 and year % 100 != 0 or year % 400 == 0 def which_day(year, month, date): days_of_month = [ [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31] ][is_leap_year(year)] total = 0 for index in range(month - 1): total += days_of_month[index] return total + date print(which_day(2019,12,31)) import pandas as pd def which_day2(s): d = pd.to_datetime(s,\"coerce\") if str(d)=='NaT': return \"\" return d.dayofyear print(which_day2('2019-12-12')) 设计一个函数返回给定文件名的后缀名。def get_filename(name): res = name.rsplit(\".\",1) return \"\" if len(res)==1 else res[-1] name=\"helrkjelr.xls\" print(get_filename(name)) 设计一个函数返回时针与分针的夹角。def times(h,m): return abs(((h+m//12)*5-m)*6) 有效括号#给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。 #有效字符串需满足： # 左括号必须用相同类型的右括号闭合。 # 左括号必须以正确的顺序闭合。 # 注意空字符串可被认为是有效字符串。 def isValid1(s): d = {')':'(',']':'[','}':'{'} stack = [None] for i in s: if i in d and d[i]==stack[-1]: stack.pop() else: stack.append(i) return len(stack)==1 s = \"()()()\" print(isValid1(s)) def isValid2(s): while '{}' in s or '()' in s or '[]' in s: s = s.replace('{}', '') s = s.replace('[]', '') s = s.replace('()', '') return s == '' 面向对象编程 定义一个类描述平面上的点并提供移动点和计算到另一个点距离的方法。from math import sqrt class Point(object): def __init__(self, x=0, y=0): self.x = x self.y = y def move_to(self, x, y): self.x = x self.y = y def move_by(self, dx, dy): self.x += dx self.y += dy def distance_to(self, other): dx = self.x - other.x dy = self.y - other.y return sqrt(dx ** 2 + dy ** 2) def __str__(self): return '(%s, %s)' % (str(self.x), str(self.y)) p1 = Point(3, 5) p2 = Point() print(p1) print(p2) p2.move_by(-1, 2) print(p2) print(p1.distance_to(p2)) 工资结算系统# 某公司有三种类型的员工 分别是部门经理、程序员和销售员需要设计一个工资结算系统 # 根据提供的员工信息来计算月薪 # 部门经理的月薪是每月固定15000元 # 程序员的月薪按本月工作时间计算 每小时150元 # 销售员的月薪是1200元的底薪加上销售额5%的提成 class Employee(object): def __init__(self,name): self._name = name def name(self): return self._name def get_salary(self): pass class Manager(Employee): def get_salary(self): return 15000.0 class Programmer(Employee): def __init__(self,name,hour=0): super().__init__(name) self._working_hour = hour def working_hour(self,hour): self._working_hour = hour def get_salary(self): return 150.0*self._working_hour class Salesman(Employee): def __init__(self,name,sales=0): super().__init__(name) self._sales = sales def sales(self,sales): self._sales = sales def get_salary(self): return 1200.0 +self._sales*0.05 emps = [Manager('a'),Programmer('b'),Salesman('c')] for emp in emps: if isinstance(emp,Programmer): emp.working_hour(int(input('%s'% emp.name()))) elif isinstance(emp,Salesman): emp.sales(float(input('%s'% emp.name()))) print(emp.name(),emp.get_salary()) "},"async/base.html":{"url":"async/base.html","title":"计算机基础","keywords":"","body":"计算机工作原理 计算机系统由硬件系统和软件系统两大部分组成。计算机硬件由运算器、控制器、存储器、输入设备和输出设备五大部分组成。 硬件 CPU:中央处理器，由控制器、运算器、寄存器组成。 控制器：对输入的指令进行分析，并统一控制计算机的各个部分完成任务的部件 运算器: 执行各种算数运算和逻辑运算 寄存器: 用于存储参与运算的各种数据以及运算结果 存储器: 内存，把执行的程序和数据存入内存中。 寄存器和存储器的区别：寄存器在于CPU中，速度块，数目有限，做运算时必须将数据存入寄存器才能运算 输入输出设备：鼠标、键盘、硬盘 总线: 可以理解成主板，为以上部件提供数据传送的公用信号线。 计算机操作系统 操作系统的五大功能，分别为：进程管理、文件管理、内存管理、输入输出设备管理、系统调用 进程管理: 进程控制、进程同步，进程通信、进程调度等 内存管理: 内存分配、内存保护和共享等 文件管理: 存储空间管理、文件读写管理和保护等 输入输出设备管理: 完成I/O请求 系统调用: 进程的执行分2个级别用户级和系统级，系统提供各种服务，当用户进程使用到这些服务时，会产生一个中断，等待调用结束，然后再处理这个进程直到结束。 进程与线程 进程(资源分配的最小单位) 在程序执行过程中分配和管理资源的基本单位，时动态的。每个进程都拥有自己的CPU和其他资源，多进程可以提高计算机的利用率 有5种状态：初始态，执行态，等待态，就绪态，终止态。 进程之间的通讯方法: 管道: 速度慢，容量有限，只能父子进程通信 FIFO: 速度慢 消息队列: 受系统限制 信号量: 只能用来同步 共享内存: 注意保持同步 线程(程序执行的最小单位) 进程只能在一个时间内干一件事，如果要同时干多件事进程就无能为力了，因为要并发，所以需要有线程。比如同时执行听、说、写操作，这就是多线程的好处。 是进程的一部分，共享进程的资源，分就绪、执行、阻塞3个状态 如果这些线程中对同一变量有读又有写操作时，就会导致变量异常。 线程同步方法: 锁机制 设置优先级队列 单CPU中进程只能是并发，多CPU计算机中进程可以并行。 单CPU单核中线程只能并发，单CPU多核中线程可以并行。 死锁 多进程因竞争资源而造成的一种僵局 原因 对系统资源的竞争 进程对资源请求和释放顺序不恰当 产生的条件 互斥条件: 进程对所请求的资源，在一段时间内这个资源只能为一个进程所占用，这样另外请求该资源的，统统都会被挂起。 不掠夺条件: 进程所获得的资源在未使用完之前，不能被其他进程强行夺走。 请求和保持条件: 保持了至少一个资源，请求了另外一个资源。 循环等待条件: 链中每一个进程已获得的资源同时被下一个进程所请求。 处理死锁的方法: 预防死锁: 破坏产生死锁的条件 避免死锁: 资源有序申请分配法 检测死锁: 设置检测机构及时检测死锁的发生 解除死锁: 检测出死锁后采取适当措施从死锁状态中解脱出来 内存管理基础 程序可执行文件的结构 heap: 堆 stack: 栈 栈 是一块连续的内存区域，用于存放本地变量，内部临时变量以及有关上下文的内存区域，程序在调用时由操作系统通过入栈出栈来完成，无须手工。 栈分静态分配和动态分配，静态分配是有编译器完成的，比如局部变量的分配，动态分配有alloca函数控制，该变量离开其作用域之后被自动释放 堆 是一块不连续的内存区域，是有系统用链表来存储的空闲内存地址，用来存放出栈之后其他所有的东西，对于堆来说，释放工作由程序员控制，容易产生内存溢出。 堆是动态分配的 "},"async/threading.html":{"url":"async/threading.html","title":"多线程","keywords":"","body":"多线程 线程是最小的执行单元，一个进程由至少一个线程组成 import threading def loop(): n = 0 while n 多线程与多核CPU import threading,multiprocessing def loop(): x = 0 while True: x +=2 for i in range(multiprocessing.cpu_count()): t = threading.Thread(target=loop) t.start() 发现多线程只在单个CPU上执行。为什么不能充分利用多核CPU呢？ GIL(全局解释锁) Python执行过程 写在源文件中的代码都是为了人类可读，机器根本不知道他是什么鬼，所以需要转化为机器认识的，这个过程就是编译。 python同样也有编译的步骤，通常python把.py源文件编译成.pyc类型的字节码文件,和CPU指令类似，但是这个.pyc并不被cpu执行，而是由python虚拟机执行，这里的python虚拟机就是所说的python解释器。 用的最多的解释器Cpython解释器，因为是用C语言写的。设计之初，为了数据安全，加了锁。这个锁就是GIL 单个线程的执行步骤: 获取GIL 执行代码 释放GIL锁 由于有GIL锁的存在，python一个进程里永远只能有一个线程在执行，这个线程就是抢到GIL锁的线程，不然就等待GIL锁的释放。每次GIL的释放，线程就各种锁竞争、切换。所以python中的多线程并不是真正的多线程。 多线程中Join的用法 默认情况 import threading,time def run(): time.sleep(2) print(threading.current_thread().name) start_time = time.time() print(threading.current_thread().name) thread_list = [] for i in range(4): thread_list.append(threading.Thread(target=run)) for t in thread_list: t.start() print('Main End',threading.current_thread().name) print(time.time()-start_time) 主线程结束，子线程继续执行自己的任务，直到全部线程执行结束，程序才结束。 设置守护线程 import threading,time def run(): time.sleep(2) print(threading.current_thread().name) start_time = time.time() print(threading.current_thread().name) thread_list = [] for i in range(4): thread_list.append(threading.Thread(target=run)) for t in thread_list: t.setDaemon(True) t.start() print('Main End',threading.current_thread().name) print(time.time()-start_time) 主线程结束,程序结束，子线程还没来得及执行 Join的用法 import threading,time def run(): time.sleep(2) print(threading.current_thread().name) start_time = time.time() print(threading.current_thread().name) thread_list = [] for i in range(4): thread_list.append(threading.Thread(target=run)) for t in thread_list: t.start() for t in thread_list: t.join() print('Main End',threading.current_thread().name) print(time.time()-start_time) 主线程一直等待全部的子线程结束，主线程才结束，程序退出。 线程同步 import time,threading balance = 0 def change_it(n): global balance balance +=n balance -=n def run_thread(n): for _ in range(1000000): change_it(n) t1 = threading.Thread(target=run_thread,args=(5,)) t2 = threading.Thread(target=run_thread,args=(8,)) t1.start() t2.start() t1.join() t2.join() print(balance) 多个线程同时读变量进行读写操作，就会导致变量异常，因为线程之间不是同步的，所以是需要线程同步。 线程锁Lock import time,threading balance = 0 def change_it(n): global balance lock.acquire() balance +=n balance -=n lock.release() def run_thread(n): for _ in range(1000000): change_it(n) lock = threading.Lock() t1 = threading.Thread(target=run_thread,args=(5,)) t2 = threading.Thread(target=run_thread,args=(8,)) t1.start() t2.start() t1.join() t2.join() print(balance) 线程优先级队列(queue) from queue import Queue import threading import time exitFlag = 0 class myThread (threading.Thread): def __init__(self, threadID, name, q): threading.Thread.__init__(self) self.threadID = threadID self.name = name self.q = q def run(self): print (\"Starting \" + self.name) process_data(self.name, self.q) print (\"Exiting \" + self.name) def process_data(threadName, q): while not exitFlag: if not workQueue.empty(): data = q.get() print (\"%s processing %s\" % (threadName, data)) threadList = [\"Thread-1\", \"Thread-2\", \"Thread-3\"] nameList = [\"One\", \"Two\", \"Three\", \"Four\", \"Five\"] queueLock = threading.Lock() workQueue = Queue(10) threads = [] threadID = 1 # 创建新线程 for tName in threadList: thread = myThread(threadID, tName, workQueue) thread.start() threads.append(thread) threadID += 1 # 填充队列 for word in nameList: workQueue.put(word) # 等待队列清空 while not workQueue.empty(): pass # 通知线程是时候退出 exitFlag = 1 # 等待所有线程完成 for t in threads: t.join() print (\"Exiting Main Thread\") "},"async/multiprocess.html":{"url":"async/multiprocess.html","title":"多进程","keywords":"","body":"多进程 Join用法同多线程一样 import os from multiprocessing import Process def run_pro(num): print(os.getpid(),num) print(\"Main Process\",os.getpid()) p_list = [] for i in range(4): p_list.append(Process(target=run_pro,args=(i,))) for p in p_list: # p.daemon = False p.start() for p in p_list: p.join() print(\"Main Process\",os.getpid()) 进程池Pool from multiprocessing import Pool import os def run_pro(num): print(os.getpid(),num) print(os.getpid(),\"Main process\") p = Pool() for i in range(5): # p.apply(run_pro,args=(i,)) p.apply_async(run_pro,args=(i,)) p.close() p.join() print(\"Main Process\") Pool由两种模式，阻塞和非阻塞，阻塞即添加进程后必须等待前面的进程执行结束才执行，非阻塞则相反。 多进程通信 多进程锁Lock from multiprocessing import Process, Lock import time class MyProcess(Process): def __init__(self, loop, lock): Process.__init__(self) self.loop = loop self.lock = lock def run(self): for count in range(self.loop): time.sleep(0.1) self.lock.acquire() print('Pid: ' + str(self.pid) + ' LoopCount: ' + str(count)) self.lock.release() lock = Lock() for i in range(10, 15): p = MyProcess(i, lock) p.start() Queue队列 from multiprocessing import Process,Queue import time buffer = Queue(10) class Producer(Process): def run(self): global buffer for num in range(5): print(\"Producer\",num) buffer.put(num) time.sleep(2) class Consumer(Process): def run(self): global buffer while True: print(\"Consumer\",buffer.get()) time.sleep(2) p = Producer() c = Consumer() p.daemon = c.daemon = True p.start() c.start() p.join() # c进程里是死循环，无法等待其结束，只能强行终止 c.terminate() "},"async/asyncio.html":{"url":"async/asyncio.html","title":"协程","keywords":"","body":"协程 子程序的切换由程序控制，没有线程切换的开销 因为只有一个线程，也就不用考虑锁的问题 def producer(c): c.send(None) n =0 while n import threading import asyncio @asyncio.coroutine def hello(): print('Hello world! (%s)' % threading.currentThread()) yield from asyncio.sleep(1) print('Hello again! (%s)' % threading.currentThread()) loop = asyncio.get_event_loop() tasks = [hello(), hello()] loop.run_until_complete(asyncio.wait(tasks)) loop.close() async和 await import threading import asyncio async def hello(): print('Hello world! (%s)' % threading.currentThread()) await asyncio.sleep(1) print('Hello again! (%s)' % threading.currentThread()) loop = asyncio.get_event_loop() tasks = [hello(), hello()] loop.run_until_complete(asyncio.wait(tasks)) loop.close() aiohttp(异步网络IO) py "},"web/network.html":{"url":"web/network.html","title":"计算机网络","keywords":"","body":"计算机网络 TCP/IP四层协议 应用层：比如HTTP、DNS、FTP、SMTP协议等 传输层： TCP和UDP，提供端到端的服务 网络层： IP协议，提供点到点的服务 链路层： 操作系统中的设备驱动程序、计算机中对应的网络接口卡 TCP协议 TCP的特性 TCP 提供一种面向连接的、可靠的字节流服务 在一个 TCP 连接中，仅有两方进行彼此通信。广播和多播不能用于 TCP TCP 使用校验和，确认和重传机制来保证可靠传输 TCP 给数据分节进行排序，并使用累积确认保证数据的顺序不变和非重复 TCP 使用滑动窗口机制来实现流量控制，通过动态改变窗口的大小进行拥塞控制 注意：TCP 并不能保证数据一定会被对方接收到，因为这是不可能的。TCP 能够做到的是，如果有可能，就把数据递送到接收方，否则就（通过放弃重传并且中断连接这一手段）通知用户。因此准确说 TCP 也不是 100% 可靠的协议，它所能提供的是数据的可靠递送或故障的可靠通知。 TCP KeepAlive TCP 的连接，实际上是一种纯软件层面的概念，在物理层面并没有“连接”这种概念。TCP 通信双方建立交互的连接，但是并不是一直存在数据交互，有些连接会在数据交互完毕后，主动释放连接，而有些不会。在长时间无数据交互的时间段内，交互双方都有可能出现掉电、死机、异常重启等各种意外，当这些意外发生之后，这些 TCP 连接并未来得及正常释放，在软件层面上，连接的另一方并不知道对端的情况，它会一直维护这个连接，长时间的积累会导致非常多的半打开连接，造成端系统资源的消耗和浪费，为了解决这个问题，在传输层可以利用 TCP 的 KeepAlive 机制实现来实现。主流的操作系统基本都在内核里支持了这个特性。 TCP KeepAlive 的基本原理是，隔一段时间给连接对端发送一个探测包，如果收到对方回应的 ACK，则认为连接还是存活的，在超过一定重试次数之后还是没有收到对方的回应，则丢弃该 TCP 连接。 UDP协议 与TCP相比，UDP缺乏可靠性。UDP本身不提供确认，序列号，超时重传等机制。UDP数据报可能在网络中被复制，被重新排序。即UDP不保证数据报会到达其最终目的地，也不保证各个数据报的先后顺序，也不保证每个数据报只到达一次 Socket基本概念 Socket 是对 TCP/IP 协议族的一种封装，是应用层与TCP/IP协议族通信的中间软件抽象层。从设计模式的角度看来，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。 Socket 还可以认为是一种网络间不同计算机上的进程通信的一种方法，利用三元组（ip地址，协议，端口）就可以唯一标识网络中的进程，网络中的进程通信可以利用这个标志与其它进程进行交互。 Socket 起源于 Unix ，Unix/Linux 基本哲学之一就是“一切皆文件”，都可以用“打开(open) –> 读写(write/read) –> 关闭(close)”模式来进行操作。因此 Socket 也被处理为一种特殊的文件。 HTTP协议 特性 构建与TCP/IP协议之上，是以一个应用层协议，默认端口80 无连接无状态的 HTTP报文 请求报文(状态行、请求头、消息主体) HTTP 定义了与服务器交互的不同方法，最基本的方法有4种，分别是GET，POST，PUT，DELETE。URL全称是资源描述符，我们可以这样认为：一个URL地址，它用于描述一个网络上的资源，而 HTTP 中的GET，POST，PUT，DELETE就对应着对这个资源的查，增，改，删4个操作。 get:用于信息获取,而且应该是安全，获取信息而非修改信息。一般不产生副作用 post: 表示可能修改变服务器上的资源的请求。 get和post区别: GET 可提交的数据量受到URL长度的限制，HTTP协议规范没有对URL长度进行限制。这个限制是特定的浏览器及服务器对它的限制 理论上讲，POST是没有大小限制的，HTTP协议规范也没有进行大小限制，出于安全考虑，服务器软件在实现时会做一定限制 GET和POST数据内容是一模一样的，只是位置不同，一个在URL里，一个在HTTP包的包体里 POST提交数据的方式 application/x-www-form-urlencoded(浏览器的原生form表单，如果不设置 enctype 属性，那么最终就会以方式提交数据) multipart/form-data(使用表单上传文件时,必须让form表单的,enctype等于multipart/form-data) 响应报文(状态行\\响应头\\响应正文) 常见的状态码有如下几种: 200 OK 客户端请求成功 301 Moved Permanently 请求永久重定向 302 Moved Temporarily 请求临时重定向 304 Not Modified 文件未修改，可以直接使用缓存的文件。 400 Bad Request 由于客户端请求有语法错误，不能被服务器所理解。 401 Unauthorized 请求未经授权。这个状态代码必须和WWW-Authenticate报头域一起使用 403 Forbidden 服务器收到请求，但是拒绝提供服务。服务器通常会在响应正文中给出不提供服务的原因 404 Not Found 请求的资源不存在，例如，输入了错误的URL 500 Internal Server Error 服务器发生不可预期的错误，导致无法完成客户端的请求。 503 Service Unavailable 服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会恢复正常。 Cookie和Session 什么是会话？ 客户端打开服务器链接请求到服务器响应客户端请求的全过程。 什么是会话跟踪？ 对同一用户对服务器的连续请求和响应进行跟踪 为什么需要会话跟踪？ 因为HTTP协议是无状态的协议，不能保存客户信息，如何判断是否是同一个用户呢？这就需要有会话跟踪 常用会话跟踪的方法？ Cookie 是web服务器发送给客户端的一小段信息 客户端可以采用两种方式来保存这个 Cookie 对象，一种方式是保存在客户端内存中，称为临时 Cookie，浏览器关闭后这个 Cookie 对象将消失。另外一种方式是保存在客户机的磁盘上，称为永久 Cookie。以后客户端只要访问该网站，就会将这个 Cookie 再次发送到服务器上，前提是这个 Cookie 在有效期内，这样就实现了对客户的跟踪。 Session 每一个用户都有一个不同的 session，各个用户之间是不能共享的，是每个用户所独享的，在 session 中可以存放信息。 在服务器端会创建一个session对象，产生一个 sessionID 来标识这个 session 对象，然后将这个sessionID 放入到Cookie中 发送到客户端，下一次访问时，sessionID 会发送到服务器，在服务器端进行识别不同的用户。 Session的实现依赖于Cookie，如果Cookie被禁用，那么session也将失效。 区别总结: session放在服务端，cookie放在客户端 session的运行依赖session ID，而session ID存放在cookie中，如果cookie被禁用，那么session也会失效 session可以放在文件、数据库、内存中 "},"web/base.html":{"url":"web/base.html","title":"web基础","keywords":"","body":""},"web/django.html":{"url":"web/django.html","title":"Django框架","keywords":"","body":""},"web/flask.html":{"url":"web/flask.html","title":"Flask框架","keywords":"","body":""}}